# 动态规划
### 一：概念
##### 1、百度百科
动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的过程。20世纪50年代初，美国数学家贝尔曼（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，从而创立了动态规划。动态规划的应用极其广泛，包括工程技术、经济、工业生产、军事以及自动化控制等领域，并在背包问题、生产经营问题、资金管理问题、资源分配问题、最短路径问题和复杂系统可靠性问题等中取得了显著的效果。
##### 2、维基百科（更易理解）
动态规划在寻找有很多重叠子问题的情况的最佳解时有效。它将问题重新组合成子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被储存，从简单的问题直到整个问题都被解决。因此，动态规划储存递迴时的结果，因而不会在解决同样的问题时花费时间。
动态规划只能应用于有最佳子结构的问题。最佳子结构的意思是局部最佳解能决定全域最佳解（对有些问题这个要求并不能完全满足，故有时需要引入一定的近似）。简单地说，问题能够分解成子问题来解决。

### 二：最简单的例题
##### 题目背景：
一只青蛙可以一次跳 1 级台阶或者一次跳 2 级台阶，例如：
跳上第 1 级台阶只有一种跳法：直接跳 1 级即可。
跳上第 2 级台阶有两种跳法：每次跳 1 级，跳两次；或者一次跳 2 级。
问要跳上第 $n$ 级台阶有多少种跳法？

##### 问题分析：
定义 $dp(n)$ 为有 $n$ 级台阶时，总共的跳法数，那么有：
```
dp(0) = 0
dp(1) = 1
dp(2) = 2
// 这三种情况 其实就是此问题的初始化值
```
以4级台阶为例，有 1+1+1+1, 1+2+1, 1+1+2, 2+1+1, 2+2五种跳法，由于青蛙一次只能跳1级或2级，青蛙要跳到第4级台阶，可以分为两种情况：
1. 从第3级台阶跳1级，到达第4级台阶：1+1+1+1, 1+2+1, 2+1+1
2. 从第3级台阶跳2级，到达第4级台阶：1+1+2, 2+2

而到达第级和第三级台阶的跳法一定是不同的,所以有：
```
dp(4) = dp(3) + dp(2)
```
推而广之，就得到了状态转移方程：
```
dp(n) = dp(n-1) + dp(n-2)
```
##### 总结：
1. 首先要搞清楚 $dp$ 数组的含义
2. 找到初始值，找初始值时一定要确保初始值的正确性，否则会导致后面的推到一概错误
3. 找到元素之间的关系式，即写出状态转移方程

### 三：机器人走棋盘问题
##### 问题背景：
现有一个 $m \times n$的棋盘，左上角有一个机器人，他每次只能向右或向下移动一格，问从左上角走到右下角共有几种走法？
![robot](https://pic1.zhimg.com/80/v2-bbbe99e44d3a46fae8a6529a25452f98_1440w.jpg?source=3af55fa1)

##### 问题分析：
###### 1. 定义 $dp$
<!-- dp[m][n]显然可以定义为从左上角(0,0)走到(m,n)位置，一共的走法数 -->
###### 2. 初始值
<!-- 由于机器人只能向右或向下走，所以要从左上角走到靠着棋盘上边的格子，只有一种走法，即一直向右走，所以这些格子的走法均为1；靠着棋盘左边的格子也是同理。 -->
###### 3. 状态转移方程
<!-- 和青蛙跳问题类似
```
dp[m][n] = dp[m-1][n] + dp[m][n-1]
``` -->

### 四：机器人走棋盘：有障碍物的版本
##### 问题背景：
和上题一样，只不过棋盘中的部分格子是有障碍物的，不能通行，如果说上题的$m \times n$棋盘矩阵中，每一个值都相同的话，此题目中的棋盘就要分为可以通行（0）和不能通行（1）
##### 问题分析：
###### 1. 定义 $dp$
<!-- 同上 -->
<!-- dp[m][n]显然可以定义为从左上角 $(0,0)$ 走到 $(m,n)$ 位置，一共的走法数 -->
###### 2. 初始值
<!-- 由于机器人只能向右或向下走，所以要从左上角走到靠着棋盘上边的格子，只有一种走法，即一直向右走，所以这些格子的走法均为1；靠着棋盘左边的格子也是同理。
但是要注意，此题中有障碍物，一旦邻着上边和左边的格子出现一个障碍物，后面就无法通行了（机器人无法向上或向左走），所以在那之后的走法皆为0
 -->
###### 3. 状态转移方程
<!-- 如果当前格子<strong>不是</strong>障碍物，那么：
```
dp[m][n] = dp[m-1][n] + dp[m][n-1]
```
如果当前格子<strong>是</strong>障碍物，那么：
```
dp[m][n] = 0
``` -->

### 五：0-1背包问题
##### 问题背景：
一个小偷去偷东西，背着一个容量为 $W$ 的背包，屋子主人共有 $N $件物品，其中第 $k$ 件物品的重量为$weight[k]$，价值为$value[k]$，问小偷最多能偷到价值为多少的物品？
<img width="500px" src ="https://pic1.zhimg.com/v2-38512729efee5eed3841cf2625a01384_b.jpg"/>
<img width="500px" src ="https://pic1.zhimg.com/v2-bbb1d71e880ec4774b5af056ba0be4e8_b.jpg"/>

##### 问题分析：
###### 1.定义dp
<!-- $dp[k][W]$ 可定义为当要偷前 $k$ 件物品，且背包剩余容量为 $W$ 时，能偷到的最多价值 -->
###### 2. 初始值
<!-- 当背包容量为0时，能偷到的最大价值一定为0
```
dp[k][0] = 0
```
同样，当要偷0件物品时，能偷到的最大价值一样为0
```
dp[0][W] = 0
```
当要偷1件物品时，若背包容量大于等于第1件物品的重量，那么能偷到的最大价值为第1件物品的价值，否则为0

```
if(W >= weight[1]){
  dp[1][W] = value[1]
} else {
  dp[1][w] = 0
}
``` 
<strong>
事实上只要在所有物品之前插入一个重量为0，价值为0的物品，并把背包容量+1，就不必做初始化了，因为 $dp$ 的所有值默认为0，而在上述条件下，初始化就已经完成了，具体看代码
</strong> -->


###### 3. 状态转移方程
<!-- 当第 $k$ 件物品的重量大于背包的重量，那么能偷到的最大价值与前 $k-1$ 件的最大价值相同
```
if(weight[k] > W){
  dp[k][W] = dp[k-1][W]
}
```
当第 $k$ 件物品的重量小于等于背包的重量，有两种选择：偷与不偷
选择偷时：
```
let value1 = dp[k-1][w-weight[k]] + value[k]
```
选择不偷时
```
let value2 = dp[k-1][w]
```
由于 $dp$ 的定义，所以 $dp[k][W]$ 应该取 $value1$ 与 $value2$ 中比较大的值
```
dp[k][W] = value1 > value2 ? value1 : value2
``` -->